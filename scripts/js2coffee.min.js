
if (typeof module == 'undefined') {
this.Narcissus = new Object;
}
(function() {
var narcissus = {
options: {
version: 185,
},
hostGlobal: this
};
Narcissus = narcissus;
})();
Narcissus.definitions = (function() {
var tokens = [
"END",
"\n", ";",
",",
"=",
"?", ":", "CONDITIONAL",
"||",
"&&",
"|",
"^",
"&",
"==", "!=", "===", "!==",
"<", "<=", ">=", ">",
"<<", ">>", ">>>",
"+", "-",
"*", "/", "%",
"!", "~", "UNARY_PLUS", "UNARY_MINUS",
"++", "--",
".",
"[", "]",
"{", "}",
"(", ")",
"SCRIPT", "BLOCK", "LABEL", "FOR_IN", "CALL", "NEW_WITH_ARGS", "INDEX",
"ARRAY_INIT", "OBJECT_INIT", "PROPERTY_INIT", "GETTER", "SETTER",
"GROUP", "LIST", "LET_BLOCK", "ARRAY_COMP", "GENERATOR", "COMP_TAIL",
"IDENTIFIER", "NUMBER", "STRING", "REGEXP",
"break",
"case", "catch", "const", "continue",
"debugger", "default", "delete", "do",
"else",
"false", "finally", "for", "function",
"if", "in", "instanceof",
"let",
"new", "null",
"return",
"switch",
"this", "throw", "true", "try", "typeof",
"var", "void",
"yield",
"while", "with",
];
var statementStartTokens = [
"break",
"const", "continue",
"debugger", "do",
"for",
"if",
"return",
"switch",
"throw", "try",
"var",
"yield",
"while", "with",
];
var opTypeNames = {
'\n':   "NEWLINE",
';':    "SEMICOLON",
',':    "COMMA",
'?':    "HOOK",
':':    "COLON",
'||':   "OR",
'&&':   "AND",
'|':    "BITWISE_OR",
'^':    "BITWISE_XOR",
'&':    "BITWISE_AND",
'===':  "STRICT_EQ",
'==':   "EQ",
'=':    "ASSIGN",
'!==':  "STRICT_NE",
'!=':   "NE",
'<<':   "LSH",
'<=':   "LE",
'<':    "LT",
'>>>':  "URSH",
'>>':   "RSH",
'>=':   "GE",
'>':    "GT",
'++':   "INCREMENT",
'--':   "DECREMENT",
'+':    "PLUS",
'-':    "MINUS",
'*':    "MUL",
'/':    "DIV",
'%':    "MOD",
'!':    "NOT",
'~':    "BITWISE_NOT",
'.':    "DOT",
'[':    "LEFT_BRACKET",
']':    "RIGHT_BRACKET",
'{':    "LEFT_CURLY",
'}':    "RIGHT_CURLY",
'(':    "LEFT_PAREN",
')':    "RIGHT_PAREN"
};
var keywords = {__proto__: null};
var tokenIds = {};
var consts = "const ";
for (var i = 0, j = tokens.length; i < j; i++) {
if (i > 0)
consts += ", ";
var t = tokens[i];
var name;
if (/^[a-z]/.test(t)) {
name = t.toUpperCase();
keywords[t] = i;
} else {
name = (/^\W/.test(t) ? opTypeNames[t] : t);
}
consts += name + " = " + i;
tokenIds[name] = i;
tokens[t] = i;
}
consts += ";";
var isStatementStartCode = {__proto__: null};
for (i = 0, j = statementStartTokens.length; i < j; i++)
isStatementStartCode[keywords[statementStartTokens[i]]] = true;
var assignOps = ['|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'];
for (i = 0, j = assignOps.length; i < j; i++) {
t = assignOps[i];
assignOps[t] = tokens[t];
}
function defineGetter(obj, prop, fn, dontDelete, dontEnum) {
Object.defineProperty(obj, prop,
{ get: fn, configurable: !dontDelete, enumerable: !dontEnum });
}
function defineProperty(obj, prop, val, dontDelete, readOnly, dontEnum) {
Object.defineProperty(obj, prop,
{ value: val, writable: !readOnly, configurable: !dontDelete,
enumerable: !dontEnum });
}
function isNativeCode(fn) {
return ((typeof fn) === "function") && fn.toString().match(/\[native code\]/);
}
function getPropertyDescriptor(obj, name) {
while (obj) {
if (({}).hasOwnProperty.call(obj, name))
return Object.getOwnPropertyDescriptor(obj, name);
obj = Object.getPrototypeOf(obj);
}
}
function getOwnProperties(obj) {
var map = {};
for (var name in Object.getOwnPropertyNames(obj))
map[name] = Object.getOwnPropertyDescriptor(obj, name);
return map;
}
function makePassthruHandler(obj) {
return {
getOwnPropertyDescriptor: function(name) {
var desc = Object.getOwnPropertyDescriptor(obj, name);
desc.configurable = true;
return desc;
},
getPropertyDescriptor: function(name) {
var desc = getPropertyDescriptor(obj, name);
desc.configurable = true;
return desc;
},
getOwnPropertyNames: function() {
return Object.getOwnPropertyNames(obj);
},
defineProperty: function(name, desc) {
Object.defineProperty(obj, name, desc);
},
"delete": function(name) { return delete obj[name]; },
fix: function() {
if (Object.isFrozen(obj)) {
return getOwnProperties(obj);
}
return undefined;
},
has: function(name) { return name in obj; },
hasOwn: function(name) { return ({}).hasOwnProperty.call(obj, name); },
get: function(receiver, name) { return obj[name]; },
set: function(receiver, name, val) { obj[name] = val; return true; },
enumerate: function() {
var result = [];
for (name in obj) { result.push(name); };
return result;
},
keys: function() { return Object.keys(obj); }
};
}
function noPropFound() { return undefined; }
var hasOwnProperty = ({}).hasOwnProperty;
function StringMap() {
this.table = Object.create(null, {});
this.size = 0;
}
StringMap.prototype = {
has: function(x) { return hasOwnProperty.call(this.table, x); },
set: function(x, v) {
if (!hasOwnProperty.call(this.table, x))
this.size++;
this.table[x] = v;
},
get: function(x) { return this.table[x]; },
getDef: function(x, thunk) {
if (!hasOwnProperty.call(this.table, x)) {
this.size++;
this.table[x] = thunk();
}
return this.table[x];
},
forEach: function(f) {
var table = this.table;
for (var key in table)
f.call(this, key, table[key]);
},
toString: function() { return "[object StringMap]" }
};
function Stack(elts) {
this.elts = elts || null;
}
Stack.prototype = {
push: function(x) {
return new Stack({ top: x, rest: this.elts });
},
top: function() {
if (!this.elts)
throw new Error("empty stack");
return this.elts.top;
},
isEmpty: function() {
return this.top === null;
},
find: function(test) {
for (var elts = this.elts; elts; elts = elts.rest) {
if (test(elts.top))
return elts.top;
}
return null;
},
has: function(x) {
return Boolean(this.find(function(elt) { return elt === x }));
},
forEach: function(f) {
for (var elts = this.elts; elts; elts = elts.rest) {
f(elts.top);
}
}
};
return {
tokens: tokens,
opTypeNames: opTypeNames,
keywords: keywords,
isStatementStartCode: isStatementStartCode,
tokenIds: tokenIds,
consts: consts,
assignOps: assignOps,
defineGetter: defineGetter,
defineProperty: defineProperty,
isNativeCode: isNativeCode,
makePassthruHandler: makePassthruHandler,
noPropFound: noPropFound,
StringMap: StringMap,
Stack: Stack
};
}());
Narcissus.lexer = (function() {
var definitions = Narcissus.definitions;
eval(definitions.consts);
var opTokens = {};
for (var op in definitions.opTypeNames) {
if (op === '\n' || op === '.')
continue;
var node = opTokens;
for (var i = 0; i < op.length; i++) {
var ch = op[i];
if (!(ch in node))
node[ch] = {};
node = node[ch];
node.op = op;
}
}
function Tokenizer(s, f, l) {
this.cursor = 0;
this.source = String(s);
this.tokens = [];
this.tokenIndex = 0;
this.lookahead = 0;
this.scanNewlines = false;
this.unexpectedEOF = false;
this.filename = f || "";
this.lineno = l || 1;
}
Tokenizer.prototype = {
get done() {
return this.peek(true) === END;
},
get token() {
return this.tokens[this.tokenIndex];
},
match: function (tt, scanOperand) {
return this.get(scanOperand) === tt || this.unget();
},
mustMatch: function (tt) {
if (!this.match(tt)) {
throw this.newSyntaxError("Missing " +
definitions.tokens[tt].toLowerCase());
}
return this.token;
},
peek: function (scanOperand) {
var tt, next;
if (this.lookahead) {
next = this.tokens[(this.tokenIndex + this.lookahead) & 3];
tt = (this.scanNewlines && next.lineno !== this.lineno)
? NEWLINE
: next.type;
} else {
tt = this.get(scanOperand);
this.unget();
}
return tt;
},
peekOnSameLine: function (scanOperand) {
this.scanNewlines = true;
var tt = this.peek(scanOperand);
this.scanNewlines = false;
return tt;
},
skip: function () {
var input = this.source;
for (;;) {
var ch = input[this.cursor++];
var next = input[this.cursor];
if (ch === '\n' && !this.scanNewlines) {
this.lineno++;
} else if (ch === '/' && next === '*') {
this.cursor++;
for (;;) {
ch = input[this.cursor++];
if (ch === undefined)
throw this.newSyntaxError("Unterminated comment");
if (ch === '*') {
next = input[this.cursor];
if (next === '/') {
this.cursor++;
break;
}
} else if (ch === '\n') {
this.lineno++;
}
}
} else if (ch === '/' && next === '/') {
this.cursor++;
for (;;) {
ch = input[this.cursor++];
if (ch === undefined)
return;
if (ch === '\n') {
this.lineno++;
break;
}
}
} else if (ch !== ' ' && ch !== '\t') {
this.cursor--;
return;
}
}
},
lexExponent: function() {
var input = this.source;
var next = input[this.cursor];
if (next === 'e' || next === 'E') {
this.cursor++;
ch = input[this.cursor++];
if (ch === '+' || ch === '-')
ch = input[this.cursor++];
if (ch < '0' || ch > '9')
throw this.newSyntaxError("Missing exponent");
do {
ch = input[this.cursor++];
} while (ch >= '0' && ch <= '9');
this.cursor--;
return true;
}
return false;
},
lexZeroNumber: function (ch) {
var token = this.token, input = this.source;
token.type = NUMBER;
ch = input[this.cursor++];
if (ch === '.') {
do {
ch = input[this.cursor++];
} while (ch >= '0' && ch <= '9');
this.cursor--;
this.lexExponent();
token.value = parseFloat(token.start, this.cursor);
} else if (ch === 'x' || ch === 'X') {
do {
ch = input[this.cursor++];
} while ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||
(ch >= 'A' && ch <= 'F'));
this.cursor--;
token.value = parseInt(input.substring(token.start, this.cursor));
} else if (ch >= '0' && ch <= '7') {
do {
ch = input[this.cursor++];
} while (ch >= '0' && ch <= '7');
this.cursor--;
token.value = parseInt(input.substring(token.start, this.cursor));
} else {
this.cursor--;
this.lexExponent();
token.value = 0;
}
},
lexNumber: function (ch) {
var token = this.token, input = this.source;
token.type = NUMBER;
var floating = false;
do {
ch = input[this.cursor++];
if (ch === '.' && !floating) {
floating = true;
ch = input[this.cursor++];
}
} while (ch >= '0' && ch <= '9');
this.cursor--;
var exponent = this.lexExponent();
floating = floating || exponent;
var str = input.substring(token.start, this.cursor);
token.value = floating ? parseFloat(str) : parseInt(str);
},
lexDot: function (ch) {
var token = this.token, input = this.source;
var next = input[this.cursor];
if (next >= '0' && next <= '9') {
do {
ch = input[this.cursor++];
} while (ch >= '0' && ch <= '9');
this.cursor--;
this.lexExponent();
token.type = NUMBER;
token.value = parseFloat(token.start, this.cursor);
} else {
token.type = DOT;
token.assignOp = null;
token.value = '.';
}
},
lexString: function (ch) {
var token = this.token, input = this.source;
token.type = STRING;
var hasEscapes = false;
var delim = ch;
while ((ch = input[this.cursor++]) !== delim) {
if (this.cursor >= input.length)
throw this.newSyntaxError("Unterminated string literal");
if (ch === '\\') {
hasEscapes = true;
if (++this.cursor == input.length)
throw this.newSyntaxError("Unterminated string literal");
}
}
token.value = hasEscapes
? eval(input.substring(token.start, this.cursor))
: input.substring(token.start + 1, this.cursor - 1);
},
lexRegExp: function (ch) {
var token = this.token, input = this.source;
token.type = REGEXP;
do {
ch = input[this.cursor++];
if (ch === '\\') {
this.cursor++;
} else if (ch === '[') {
do {
if (ch === undefined)
throw this.newSyntaxError("Unterminated character class");
if (ch === '\\')
this.cursor++;
ch = input[this.cursor++];
} while (ch !== ']');
} else if (ch === undefined) {
throw this.newSyntaxError("Unterminated regex");
}
} while (ch !== '/');
do {
ch = input[this.cursor++];
} while (ch >= 'a' && ch <= 'z');
this.cursor--;
token.value = eval(input.substring(token.start, this.cursor));
},
lexOp: function (ch) {
var token = this.token, input = this.source;
var node = opTokens[ch];
var next = input[this.cursor];
if (next in node) {
node = node[next];
this.cursor++;
next = input[this.cursor];
if (next in node) {
node = node[next];
this.cursor++;
next = input[this.cursor];
}
}
var op = node.op;
if (definitions.assignOps[op] && input[this.cursor] === '=') {
this.cursor++;
token.type = ASSIGN;
token.assignOp = definitions.tokenIds[definitions.opTypeNames[op]];
op += '=';
} else {
token.type = definitions.tokenIds[definitions.opTypeNames[op]];
token.assignOp = null;
}
token.value = op;
},
lexIdent: function (ch) {
var token = this.token, input = this.source;
do {
ch = input[this.cursor++];
} while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
(ch >= '0' && ch <= '9') || ch === '$' || ch === '_');
this.cursor--;
var id = input.substring(token.start, this.cursor);
token.type = definitions.keywords[id] || IDENTIFIER;
token.value = id;
},
get: function (scanOperand) {
var token;
while (this.lookahead) {
--this.lookahead;
this.tokenIndex = (this.tokenIndex + 1) & 3;
token = this.tokens[this.tokenIndex];
if (token.type !== NEWLINE || this.scanNewlines)
return token.type;
}
this.skip();
this.tokenIndex = (this.tokenIndex + 1) & 3;
token = this.tokens[this.tokenIndex];
if (!token)
this.tokens[this.tokenIndex] = token = {};
var input = this.source;
if (this.cursor === input.length)
return token.type = END;
token.start = this.cursor;
token.lineno = this.lineno;
var ch = input[this.cursor++];
if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '$' || ch === '_') {
this.lexIdent(ch);
} else if (scanOperand && ch === '/') {
this.lexRegExp(ch);
} else if (ch in opTokens) {
this.lexOp(ch);
} else if (ch === '.') {
this.lexDot(ch);
} else if (ch >= '1' && ch <= '9') {
this.lexNumber(ch);
} else if (ch === '0') {
this.lexZeroNumber(ch);
} else if (ch === '"' || ch === "'") {
this.lexString(ch);
} else if (this.scanNewlines && ch === '\n') {
token.type = NEWLINE;
token.value = '\n';
this.lineno++;
} else {
throw this.newSyntaxError("Illegal token");
}
token.end = this.cursor;
return token.type;
},
unget: function () {
if (++this.lookahead === 4) throw "PANIC: too much lookahead!";
this.tokenIndex = (this.tokenIndex - 1) & 3;
},
newSyntaxError: function (m) {
var e = new SyntaxError(m, this.filename, this.lineno);
e.source = this.source;
e.cursor = this.lookahead
? this.tokens[(this.tokenIndex + this.lookahead) & 3].start
: this.cursor;
return e;
},
};
return { Tokenizer: Tokenizer };
}());
Narcissus.parser = (function() {
var lexer = Narcissus.lexer;
var definitions = Narcissus.definitions;
const StringMap = definitions.StringMap;
const Stack = definitions.Stack;
eval(definitions.consts);
function pushDestructuringVarDecls(n, s) {
for (var i in n) {
var sub = n[i];
if (sub.type === IDENTIFIER) {
s.varDecls.push(sub);
} else {
pushDestructuringVarDecls(sub, s);
}
}
}
const NESTING_TOP = 0, NESTING_SHALLOW = 1, NESTING_DEEP = 2;
function StaticContext(parentScript, parentBlock, inFunction, inForLoopInit, nesting) {
this.parentScript = parentScript;
this.parentBlock = parentBlock;
this.inFunction = inFunction;
this.inForLoopInit = inForLoopInit;
this.nesting = nesting;
this.allLabels = new Stack();
this.currentLabels = new Stack();
this.labeledTargets = new Stack();
this.defaultTarget = null;
Narcissus.options.ecma3OnlyMode && (this.ecma3OnlyMode = true);
Narcissus.options.parenFreeMode && (this.parenFreeMode = true);
}
StaticContext.prototype = {
ecma3OnlyMode: false,
parenFreeMode: false,
update: function(ext) {
var desc = {};
for (var key in ext) {
desc[key] = {
value: ext[key],
writable: true,
enumerable: true,
configurable: true
}
}
return Object.create(this, desc);
},
pushLabel: function(label) {
return this.update({ currentLabels: this.currentLabels.push(label),
allLabels: this.allLabels.push(label) });
},
pushTarget: function(target) {
var isDefaultTarget = target.isLoop || target.type === SWITCH;
if (this.currentLabels.isEmpty()) {
return isDefaultTarget
? this.update({ defaultTarget: target })
: this;
}
target.labels = new StringMap();
this.currentLabels.forEach(function(label) {
target.labels.set(label, true);
});
return this.update({ currentLabels: new Stack(),
labeledTargets: this.labeledTargets.push(target),
defaultTarget: isDefaultTarget
? target
: this.defaultTarget });
},
nest: function(atLeast) {
var nesting = Math.max(this.nesting, atLeast);
return (nesting !== this.nesting)
? this.update({ nesting: nesting })
: this;
}
};
function Script(t, inFunction) {
var n = new Node(t, scriptInit());
var x = new StaticContext(n, n, inFunction, false, NESTING_TOP);
Statements(t, x, n);
return n;
}
definitions.defineProperty(Array.prototype, "top",
function() {
return this.length && this[this.length-1];
}, false, false, true);
function Node(t, init) {
var token = t.token;
if (token) {
this.type = token.type;
this.value = token.value;
this.lineno = token.lineno;
this.start = token.start;
this.end = token.end;
} else {
this.lineno = t.lineno;
}
this.tokenizer = t;
this.children = [];
for (var prop in init)
this[prop] = init[prop];
}
var Np = Node.prototype = {};
Np.constructor = Node;
Np.toSource = Object.prototype.toSource;
Np.push = function (kid) {
if (kid !== null) {
if (kid.start < this.start)
this.start = kid.start;
if (this.end < kid.end)
this.end = kid.end;
}
return this.children.push(kid);
}
Node.indentLevel = 0;
function tokenString(tt) {
var t = definitions.tokens[tt];
return /^\W/.test(t) ? definitions.opTypeNames[t] : t.toUpperCase();
}
Np.toString = function () {
var a = [];
for (var i in this) {
if (this.hasOwnProperty(i) && i !== 'type' && i !== 'target')
a.push({id: i, value: this[i]});
}
a.sort(function (a,b) { return (a.id < b.id) ? -1 : 1; });
const INDENTATION = "    ";
var n = ++Node.indentLevel;
var s = "{\n" + INDENTATION.repeat(n) + "type: " + tokenString(this.type);
for (i = 0; i < a.length; i++)
s += ",\n" + INDENTATION.repeat(n) + a[i].id + ": " + a[i].value;
n = --Node.indentLevel;
s += "\n" + INDENTATION.repeat(n) + "}";
return s;
}
Np.getSource = function () {
return this.tokenizer.source.slice(this.start, this.end);
};
const LOOP_INIT = { isLoop: true };
function blockInit() {
return { type: BLOCK, varDecls: [] };
}
function scriptInit() {
return { type: SCRIPT,
funDecls: [],
varDecls: [],
modDecls: [],
impDecls: [],
expDecls: [],
loadDeps: [],
hasEmptyReturn: false,
hasReturnWithValue: false,
isGenerator: false };
}
definitions.defineGetter(Np, "filename",
function() {
return this.tokenizer.filename;
});
definitions.defineGetter(Np, "length",
function() {
throw new Error("Node.prototype.length is gone; " +
"use n.children.length instead");
});
definitions.defineProperty(String.prototype, "repeat",
function(n) {
var s = "", t = this + s;
while (--n >= 0)
s += t;
return s;
}, false, false, true);
function MaybeLeftParen(t, x) {
if (x.parenFreeMode)
return t.match(LEFT_PAREN) ? LEFT_PAREN : END;
return t.mustMatch(LEFT_PAREN).type;
}
function MaybeRightParen(t, p) {
if (p === LEFT_PAREN)
t.mustMatch(RIGHT_PAREN);
}
function Statements(t, x, n) {
try {
while (!t.done && t.peek(true) !== RIGHT_CURLY)
{ n.push(Statement(t, x)); }
} catch (e) {
if (t.done)
{ t.unexpectedEOF = true; }
throw(e);
}
}
function Block(t, x) {
t.mustMatch(LEFT_CURLY);
var n = new Node(t, blockInit());
Statements(t, x.update({ parentBlock: n }).pushTarget(n), n);
t.mustMatch(RIGHT_CURLY);
return n;
}
const DECLARED_FORM = 0, EXPRESSED_FORM = 1, STATEMENT_FORM = 2;
function Statement(t, x) {
var i, label, n, n2, p, c, ss, tt = t.get(true), tt2, x2, x3;
switch (tt) {
case FUNCTION:
return FunctionDefinition(t, x, true,
(x.nesting !== NESTING_TOP)
? STATEMENT_FORM
: DECLARED_FORM);
case LEFT_CURLY:
n = new Node(t, blockInit());
Statements(t, x.update({ parentBlock: n }).pushTarget(n).nest(NESTING_SHALLOW), n);
t.mustMatch(RIGHT_CURLY);
return n;
case IF:
n = new Node(t);
n.condition = HeadExpression(t, x);
x2 = x.pushTarget(n).nest(NESTING_DEEP);
n.thenPart = Statement(t, x2);
n.elsePart = t.match(ELSE) ? Statement(t, x2) : null;
return n;
case SWITCH:
n = new Node(t, { cases: [], defaultIndex: -1 });
n.discriminant = HeadExpression(t, x);
x2 = x.pushTarget(n).nest(NESTING_DEEP);
t.mustMatch(LEFT_CURLY);
while ((tt = t.get()) !== RIGHT_CURLY) {
switch (tt) {
case DEFAULT:
if (n.defaultIndex >= 0)
throw t.newSyntaxError("More than one switch default");
case CASE:
n2 = new Node(t);
if (tt === DEFAULT)
n.defaultIndex = n.cases.length;
else
n2.caseLabel = Expression(t, x2, COLON);
break;
default:
throw t.newSyntaxError("Invalid switch case");
}
t.mustMatch(COLON);
n2.statements = new Node(t, blockInit());
while ((tt=t.peek(true)) !== CASE && tt !== DEFAULT &&
tt !== RIGHT_CURLY)
n2.statements.push(Statement(t, x2));
n.cases.push(n2);
}
return n;
case FOR:
n = new Node(t, LOOP_INIT);
if (t.match(IDENTIFIER)) {
if (t.token.value === "each")
n.isEach = true;
else
t.unget();
}
if (!x.parenFreeMode)
t.mustMatch(LEFT_PAREN);
x2 = x.pushTarget(n).nest(NESTING_DEEP);
x3 = x.update({ inForLoopInit: true });
if ((tt = t.peek()) !== SEMICOLON) {
if (tt === VAR || tt === CONST) {
t.get();
n2 = Variables(t, x3);
} else if (tt === LET) {
t.get();
if (t.peek() === LEFT_PAREN) {
n2 = LetBlock(t, x3, false);
} else {
x3.parentBlock = n;
n.varDecls = [];
n2 = Variables(t, x3);
}
} else {
n2 = Expression(t, x3);
}
}
if (n2 && t.match(IN)) {
n.type = FOR_IN;
n.object = Expression(t, x3);
if (n2.type === VAR || n2.type === LET) {
c = n2.children;
if (c.length !== 1 && n2.destructurings.length !== 1) {
throw new SyntaxError("Invalid for..in left-hand side",
t.filename, n2.lineno);
}
if (n2.destructurings.length > 0) {
n.iterator = n2.destructurings[0];
} else {
n.iterator = c[0];
}
n.varDecl = n2;
} else {
if (n2.type === ARRAY_INIT || n2.type === OBJECT_INIT) {
n2.destructuredNames = checkDestructuring(t, x3, n2);
}
n.iterator = n2;
}
} else {
n.setup = n2;
t.mustMatch(SEMICOLON);
if (n.isEach)
throw t.newSyntaxError("Invalid for each..in loop");
n.condition = (t.peek() === SEMICOLON)
? null
: Expression(t, x3);
t.mustMatch(SEMICOLON);
tt2 = t.peek();
n.update = (x.parenFreeMode
? tt2 === LEFT_CURLY || definitions.isStatementStartCode[tt2]
: tt2 === RIGHT_PAREN)
? null
: Expression(t, x3);
}
if (!x.parenFreeMode)
t.mustMatch(RIGHT_PAREN);
n.body = Statement(t, x2);
return n;
case WHILE:
n = new Node(t, { isLoop: true });
n.condition = HeadExpression(t, x);
n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));
return n;
case DO:
n = new Node(t, { isLoop: true });
n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));
t.mustMatch(WHILE);
n.condition = HeadExpression(t, x);
if (!x.ecmaStrictMode) {
t.match(SEMICOLON);
return n;
}
break;
case BREAK:
case CONTINUE:
n = new Node(t);
x2 = x.pushTarget(n);
if (t.peekOnSameLine() === IDENTIFIER) {
t.get();
n.label = t.token.value;
}
n.target = n.label
? x2.labeledTargets.find(function(target) { return target.labels.has(n.label) })
: x2.defaultTarget;
if (!n.target)
throw t.newSyntaxError("Invalid " + ((tt === BREAK) ? "break" : "continue"));
if (!n.target.isLoop && tt === CONTINUE)
throw t.newSyntaxError("Invalid continue");
break;
case TRY:
n = new Node(t, { catchClauses: [] });
n.tryBlock = Block(t, x);
while (t.match(CATCH)) {
n2 = new Node(t);
p = MaybeLeftParen(t, x);
switch (t.get()) {
case LEFT_BRACKET:
case LEFT_CURLY:
t.unget();
n2.varName = DestructuringExpression(t, x, true);
break;
case IDENTIFIER:
n2.varName = t.token.value;
break;
default:
throw t.newSyntaxError("missing identifier in catch");
break;
}
if (t.match(IF)) {
if (x.ecma3OnlyMode)
throw t.newSyntaxError("Illegal catch guard");
if (n.catchClauses.length && !n.catchClauses.top().guard)
throw t.newSyntaxError("Guarded catch after unguarded");
n2.guard = Expression(t, x);
}
MaybeRightParen(t, p);
n2.block = Block(t, x);
n.catchClauses.push(n2);
}
if (t.match(FINALLY))
n.finallyBlock = Block(t, x);
if (!n.catchClauses.length && !n.finallyBlock)
throw t.newSyntaxError("Invalid try statement");
return n;
case CATCH:
case FINALLY:
throw t.newSyntaxError(definitions.tokens[tt] + " without preceding try");
case THROW:
n = new Node(t);
n.exception = Expression(t, x);
break;
case RETURN:
n = ReturnOrYield(t, x);
break;
case WITH:
n = new Node(t);
n.object = HeadExpression(t, x);
n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));
return n;
case VAR:
case CONST:
n = Variables(t, x);
break;
case LET:
if (t.peek() === LEFT_PAREN)
n = LetBlock(t, x, true);
else
n = Variables(t, x);
break;
case DEBUGGER:
n = new Node(t);
break;
case NEWLINE:
case SEMICOLON:
n = new Node(t, { type: SEMICOLON });
n.expression = null;
return n;
default:
if (tt === IDENTIFIER) {
tt = t.peek();
if (tt === COLON) {
label = t.token.value;
if (x.allLabels.has(label))
throw t.newSyntaxError("Duplicate label");
t.get();
n = new Node(t, { type: LABEL, label: label });
n.statement = Statement(t, x.pushLabel(label).nest(NESTING_SHALLOW));
n.target = (n.statement.type === LABEL) ? n.statement.target : n.statement;
return n;
}
}
n = new Node(t, { type: SEMICOLON });
t.unget();
n.expression = Expression(t, x);
n.end = n.expression.end;
break;
}
MagicalSemicolon(t);
return n;
}
function MagicalSemicolon(t) {
var tt;
if (t.lineno === t.token.lineno) {
tt = t.peekOnSameLine();
if (tt !== END && tt !== NEWLINE && tt !== SEMICOLON && tt !== RIGHT_CURLY)
throw t.newSyntaxError("missing ; before statement");
}
t.match(SEMICOLON);
}
function ReturnOrYield(t, x) {
var n, b, tt = t.token.type, tt2;
var parentScript = x.parentScript;
if (tt === RETURN) {
if (!x.inFunction)
throw t.newSyntaxError("Return not in function");
} else   {
if (!x.inFunction)
throw t.newSyntaxError("Yield not in function");
parentScript.isGenerator = true;
}
n = new Node(t, { value: undefined });
tt2 = t.peek(true);
if (tt2 !== END && tt2 !== NEWLINE &&
tt2 !== SEMICOLON && tt2 !== RIGHT_CURLY
&& (tt !== YIELD ||
(tt2 !== tt && tt2 !== RIGHT_BRACKET && tt2 !== RIGHT_PAREN &&
tt2 !== COLON && tt2 !== COMMA))) {
if (tt === RETURN) {
n.value = Expression(t, x);
parentScript.hasReturnWithValue = true;
} else {
n.value = AssignExpression(t, x);
}
} else if (tt === RETURN) {
parentScript.hasEmptyReturn = true;
}
if (parentScript.hasReturnWithValue && parentScript.isGenerator)
throw t.newSyntaxError("Generator returns a value");
return n;
}
function FunctionDefinition(t, x, requireName, functionForm) {
var tt;
var f = new Node(t, { params: [] });
if (f.type !== FUNCTION)
f.type = (f.value === "get") ? GETTER : SETTER;
if (t.match(IDENTIFIER))
f.name = t.token.value;
else if (requireName)
throw t.newSyntaxError("missing function identifier");
var x2 = new StaticContext(null, null, true, false, NESTING_TOP);
t.mustMatch(LEFT_PAREN);
if (!t.match(RIGHT_PAREN)) {
do {
switch (t.get()) {
case LEFT_BRACKET:
case LEFT_CURLY:
t.unget();
f.params.push(DestructuringExpression(t, x2));
break;
case IDENTIFIER:
f.params.push(t.token.value);
break;
default:
throw t.newSyntaxError("missing formal parameter");
break;
}
} while (t.match(COMMA));
t.mustMatch(RIGHT_PAREN);
}
tt = t.get();
if (tt !== LEFT_CURLY)
t.unget();
if (tt !== LEFT_CURLY) {
f.body = AssignExpression(t, x2);
if (f.body.isGenerator)
throw t.newSyntaxError("Generator returns a value");
} else {
f.body = Script(t, true);
}
if (tt === LEFT_CURLY)
t.mustMatch(RIGHT_CURLY);
f.end = t.token.end;
f.functionForm = functionForm;
if (functionForm === DECLARED_FORM)
x.parentScript.funDecls.push(f);
return f;
}
function Variables(t, x, letBlock) {
var n, n2, ss, i, s, tt;
tt = t.token.type;
switch (tt) {
case VAR:
case CONST:
s = x.parentScript;
break;
case LET:
s = x.parentBlock;
break;
case LEFT_PAREN:
tt = LET;
s = letBlock;
break;
}
n = new Node(t, { type: tt, destructurings: [] });
do {
tt = t.get();
if (tt === LEFT_BRACKET || tt === LEFT_CURLY) {
t.unget();
var dexp = DestructuringExpression(t, x, true);
n2 = new Node(t, { type: IDENTIFIER,
name: dexp,
readOnly: n.type === CONST });
n.push(n2);
pushDestructuringVarDecls(n2.name.destructuredNames, s);
n.destructurings.push({ exp: dexp, decl: n2 });
if (x.inForLoopInit && t.peek() === IN) {
continue;
}
t.mustMatch(ASSIGN);
if (t.token.assignOp)
throw t.newSyntaxError("Invalid variable initialization");
n2.initializer = AssignExpression(t, x);
continue;
}
if (tt !== IDENTIFIER)
throw t.newSyntaxError("missing variable name");
n2 = new Node(t, { type: IDENTIFIER,
name: t.token.value,
readOnly: n.type === CONST });
n.push(n2);
s.varDecls.push(n2);
if (t.match(ASSIGN)) {
if (t.token.assignOp)
throw t.newSyntaxError("Invalid variable initialization");
n2.initializer = AssignExpression(t, x);
}
} while (t.match(COMMA));
return n;
}
function LetBlock(t, x, isStatement) {
var n, n2;
n = new Node(t, { type: LET_BLOCK, varDecls: [] });
t.mustMatch(LEFT_PAREN);
n.variables = Variables(t, x, n);
t.mustMatch(RIGHT_PAREN);
if (isStatement && t.peek() !== LEFT_CURLY) {
n2 = new Node(t, { type: SEMICOLON,
expression: n });
isStatement = false;
}
if (isStatement)
n.block = Block(t, x);
else
n.expression = AssignExpression(t, x);
return n;
}
function checkDestructuring(t, x, n, simpleNamesOnly) {
if (n.type === ARRAY_COMP)
throw t.newSyntaxError("Invalid array comprehension left-hand side");
if (n.type !== ARRAY_INIT && n.type !== OBJECT_INIT)
return;
var lhss = {};
var nn, n2, idx, sub, cc, c = n.children;
for (var i = 0, j = c.length; i < j; i++) {
if (!(nn = c[i]))
continue;
if (nn.type === PROPERTY_INIT) {
cc = nn.children;
sub = cc[1];
idx = cc[0].value;
} else if (n.type === OBJECT_INIT) {
sub = nn;
idx = nn.value;
} else {
sub = nn;
idx = i;
}
if (sub.type === ARRAY_INIT || sub.type === OBJECT_INIT) {
lhss[idx] = checkDestructuring(t, x, sub, simpleNamesOnly);
} else {
if (simpleNamesOnly && sub.type !== IDENTIFIER) {
throw t.newSyntaxError("missing name in pattern");
}
lhss[idx] = sub;
}
}
return lhss;
}
function DestructuringExpression(t, x, simpleNamesOnly) {
var n = PrimaryExpression(t, x);
n.destructuredNames = checkDestructuring(t, x, n, simpleNamesOnly);
return n;
}
function GeneratorExpression(t, x, e) {
return new Node(t, { type: GENERATOR,
expression: e,
tail: ComprehensionTail(t, x) });
}
function ComprehensionTail(t, x) {
var body, n, n2, n3, p;
body = new Node(t, { type: COMP_TAIL });
do {
n = new Node(t, { type: FOR_IN, isLoop: true });
if (t.match(IDENTIFIER)) {
if (t.token.value === "each")
n.isEach = true;
else
t.unget();
}
p = MaybeLeftParen(t, x);
switch(t.get()) {
case LEFT_BRACKET:
case LEFT_CURLY:
t.unget();
n.iterator = DestructuringExpression(t, x);
break;
case IDENTIFIER:
n.iterator = n3 = new Node(t, { type: IDENTIFIER });
n3.name = n3.value;
n.varDecl = n2 = new Node(t, { type: VAR });
n2.push(n3);
x.parentScript.varDecls.push(n3);
break;
default:
throw t.newSyntaxError("missing identifier");
}
t.mustMatch(IN);
n.object = Expression(t, x);
MaybeRightParen(t, p);
body.push(n);
} while (t.match(FOR));
if (t.match(IF))
body.guard = HeadExpression(t, x);
return body;
}
function HeadExpression(t, x) {
var p = MaybeLeftParen(t, x);
var n = ParenExpression(t, x);
MaybeRightParen(t, p);
if (p === END && !n.parenthesized) {
var tt = t.peek();
if (tt !== LEFT_CURLY && !definitions.isStatementStartCode[tt])
throw t.newSyntaxError("Unparenthesized head followed by unbraced body");
}
return n;
}
function ParenExpression(t, x) {
var n = Expression(t, x.update({ inForLoopInit: x.inForLoopInit &&
(t.token.type === LEFT_PAREN) }));
if (t.match(FOR)) {
if (n.type === YIELD && !n.parenthesized)
throw t.newSyntaxError("Yield expression must be parenthesized");
if (n.type === COMMA && !n.parenthesized)
throw t.newSyntaxError("Generator expression must be parenthesized");
n = GeneratorExpression(t, x, n);
}
return n;
}
function Expression(t, x) {
var n, n2;
n = AssignExpression(t, x);
if (t.match(COMMA)) {
n2 = new Node(t, { type: COMMA });
n2.push(n);
n = n2;
do {
n2 = n.children[n.children.length-1];
if (n2.type === YIELD && !n2.parenthesized)
throw t.newSyntaxError("Yield expression must be parenthesized");
n.push(AssignExpression(t, x));
} while (t.match(COMMA));
}
return n;
}
function AssignExpression(t, x) {
var n, lhs;
if (t.match(YIELD, true))
return ReturnOrYield(t, x);
n = new Node(t, { type: ASSIGN });
lhs = ConditionalExpression(t, x);
if (!t.match(ASSIGN)) {
return lhs;
}
switch (lhs.type) {
case OBJECT_INIT:
case ARRAY_INIT:
lhs.destructuredNames = checkDestructuring(t, x, lhs);
case IDENTIFIER: case DOT: case INDEX: case CALL:
break;
default:
throw t.newSyntaxError("Bad left-hand side of assignment");
break;
}
n.assignOp = t.token.assignOp;
n.push(lhs);
n.push(AssignExpression(t, x));
return n;
}
function ConditionalExpression(t, x) {
var n, n2;
n = OrExpression(t, x);
if (t.match(HOOK)) {
n2 = n;
n = new Node(t, { type: HOOK });
n.push(n2);
n.push(AssignExpression(t, x.update({ inForLoopInit: false })));
if (!t.match(COLON))
throw t.newSyntaxError("missing : after ?");
n.push(AssignExpression(t, x));
}
return n;
}
function OrExpression(t, x) {
var n, n2;
n = AndExpression(t, x);
while (t.match(OR)) {
n2 = new Node(t);
n2.push(n);
n2.push(AndExpression(t, x));
n = n2;
}
return n;
}
function AndExpression(t, x) {
var n, n2;
n = BitwiseOrExpression(t, x);
while (t.match(AND)) {
n2 = new Node(t);
n2.push(n);
n2.push(BitwiseOrExpression(t, x));
n = n2;
}
return n;
}
function BitwiseOrExpression(t, x) {
var n, n2;
n = BitwiseXorExpression(t, x);
while (t.match(BITWISE_OR)) {
n2 = new Node(t);
n2.push(n);
n2.push(BitwiseXorExpression(t, x));
n = n2;
}
return n;
}
function BitwiseXorExpression(t, x) {
var n, n2;
n = BitwiseAndExpression(t, x);
while (t.match(BITWISE_XOR)) {
n2 = new Node(t);
n2.push(n);
n2.push(BitwiseAndExpression(t, x));
n = n2;
}
return n;
}
function BitwiseAndExpression(t, x) {
var n, n2;
n = EqualityExpression(t, x);
while (t.match(BITWISE_AND)) {
n2 = new Node(t);
n2.push(n);
n2.push(EqualityExpression(t, x));
n = n2;
}
return n;
}
function EqualityExpression(t, x) {
var n, n2;
n = RelationalExpression(t, x);
while (t.match(EQ) || t.match(NE) ||
t.match(STRICT_EQ) || t.match(STRICT_NE)) {
n2 = new Node(t);
n2.push(n);
n2.push(RelationalExpression(t, x));
n = n2;
}
return n;
}
function RelationalExpression(t, x) {
var n, n2;
var x2 = x.update({ inForLoopInit: false });
n = ShiftExpression(t, x2);
while ((t.match(LT) || t.match(LE) || t.match(GE) || t.match(GT) ||
(!x.inForLoopInit && t.match(IN)) ||
t.match(INSTANCEOF))) {
n2 = new Node(t);
n2.push(n);
n2.push(ShiftExpression(t, x2));
n = n2;
}
return n;
}
function ShiftExpression(t, x) {
var n, n2;
n = AddExpression(t, x);
while (t.match(LSH) || t.match(RSH) || t.match(URSH)) {
n2 = new Node(t);
n2.push(n);
n2.push(AddExpression(t, x));
n = n2;
}
return n;
}
function AddExpression(t, x) {
var n, n2;
n = MultiplyExpression(t, x);
while (t.match(PLUS) || t.match(MINUS)) {
n2 = new Node(t);
n2.push(n);
n2.push(MultiplyExpression(t, x));
n = n2;
}
return n;
}
function MultiplyExpression(t, x) {
var n, n2;
n = UnaryExpression(t, x);
while (t.match(MUL) || t.match(DIV) || t.match(MOD)) {
n2 = new Node(t);
n2.push(n);
n2.push(UnaryExpression(t, x));
n = n2;
}
return n;
}
function UnaryExpression(t, x) {
var n, n2, tt;
switch (tt = t.get(true)) {
case DELETE: case VOID: case TYPEOF:
case NOT: case BITWISE_NOT: case PLUS: case MINUS:
if (tt === PLUS)
n = new Node(t, { type: UNARY_PLUS });
else if (tt === MINUS)
n = new Node(t, { type: UNARY_MINUS });
else
n = new Node(t);
n.push(UnaryExpression(t, x));
break;
case INCREMENT:
case DECREMENT:
n = new Node(t);
n.push(MemberExpression(t, x, true));
break;
default:
t.unget();
n = MemberExpression(t, x, true);
if (t.tokens[(t.tokenIndex + t.lookahead - 1) & 3].lineno ===
t.lineno) {
if (t.match(INCREMENT) || t.match(DECREMENT)) {
n2 = new Node(t, { postfix: true });
n2.push(n);
n = n2;
}
}
break;
}
return n;
}
function MemberExpression(t, x, allowCallSyntax) {
var n, n2, name, tt;
if (t.match(NEW)) {
n = new Node(t);
n.push(MemberExpression(t, x, false));
if (t.match(LEFT_PAREN)) {
n.type = NEW_WITH_ARGS;
n.push(ArgumentList(t, x));
}
} else {
n = PrimaryExpression(t, x);
}
while ((tt = t.get()) !== END) {
switch (tt) {
case DOT:
n2 = new Node(t);
n2.push(n);
t.mustMatch(IDENTIFIER);
n2.push(new Node(t));
break;
case LEFT_BRACKET:
n2 = new Node(t, { type: INDEX });
n2.push(n);
n2.push(Expression(t, x));
t.mustMatch(RIGHT_BRACKET);
break;
case LEFT_PAREN:
if (allowCallSyntax) {
n2 = new Node(t, { type: CALL });
n2.push(n);
n2.push(ArgumentList(t, x));
break;
}
default:
t.unget();
return n;
}
n = n2;
}
return n;
}
function ArgumentList(t, x) {
var n, n2;
n = new Node(t, { type: LIST });
if (t.match(RIGHT_PAREN, true))
return n;
do {
n2 = AssignExpression(t, x);
if (n2.type === YIELD && !n2.parenthesized && t.peek() === COMMA)
throw t.newSyntaxError("Yield expression must be parenthesized");
if (t.match(FOR)) {
n2 = GeneratorExpression(t, x, n2);
if (n.children.length > 1 || t.peek(true) === COMMA)
throw t.newSyntaxError("Generator expression must be parenthesized");
}
n.push(n2);
} while (t.match(COMMA));
t.mustMatch(RIGHT_PAREN);
return n;
}
function PrimaryExpression(t, x) {
var n, n2, tt = t.get(true);
switch (tt) {
case FUNCTION:
n = FunctionDefinition(t, x, false, EXPRESSED_FORM);
break;
case LEFT_BRACKET:
n = new Node(t, { type: ARRAY_INIT });
while ((tt = t.peek(true)) !== RIGHT_BRACKET) {
if (tt === COMMA) {
t.get();
n.push(null);
continue;
}
n.push(AssignExpression(t, x));
if (tt !== COMMA && !t.match(COMMA))
break;
}
if (n.children.length === 1 && t.match(FOR)) {
n2 = new Node(t, { type: ARRAY_COMP,
expression: n.children[0],
tail: ComprehensionTail(t, x) });
n = n2;
}
t.mustMatch(RIGHT_BRACKET);
break;
case LEFT_CURLY:
var id, fd;
n = new Node(t, { type: OBJECT_INIT });
object_init:
if (!t.match(RIGHT_CURLY)) {
do {
tt = t.get();
if ((t.token.value === "get" || t.token.value === "set") &&
t.peek() === IDENTIFIER) {
if (x.ecma3OnlyMode)
throw t.newSyntaxError("Illegal property accessor");
n.push(FunctionDefinition(t, x, true, EXPRESSED_FORM));
} else {
switch (tt) {
case IDENTIFIER: case NUMBER: case STRING:
id = new Node(t, { type: IDENTIFIER });
break;
case RIGHT_CURLY:
if (x.ecma3OnlyMode)
throw t.newSyntaxError("Illegal trailing ,");
break object_init;
default:
if (t.token.value in definitions.keywords) {
id = new Node(t, { type: IDENTIFIER });
break;
}
throw t.newSyntaxError("Invalid property name");
}
if (t.match(COLON)) {
n2 = new Node(t, { type: PROPERTY_INIT });
n2.push(id);
n2.push(AssignExpression(t, x));
n.push(n2);
} else {
if (t.peek() !== COMMA && t.peek() !== RIGHT_CURLY)
throw t.newSyntaxError("missing : after property");
n.push(id);
}
}
} while (t.match(COMMA));
t.mustMatch(RIGHT_CURLY);
}
break;
case LEFT_PAREN:
n = ParenExpression(t, x);
t.mustMatch(RIGHT_PAREN);
n.parenthesized = true;
break;
case LET:
n = LetBlock(t, x, false);
break;
case NULL: case THIS: case TRUE: case FALSE:
case IDENTIFIER: case NUMBER: case STRING: case REGEXP:
n = new Node(t);
break;
default:
throw t.newSyntaxError("missing operand");
break;
}
return n;
}
function parse(s, f, l) {
var t = new lexer.Tokenizer(s, f, l);
var n = Script(t, false);
if (!t.done)
throw t.newSyntaxError("Syntax error");
return n;
}
function parseStdin(s, ln) {
for (;;) {
try {
var t = new lexer.Tokenizer(s, "stdin", ln.value);
var n = Script(t, false);
ln.value = t.lineno;
return n;
} catch (e) {
if (!t.unexpectedEOF)
throw e;
var more = readline();
if (!more)
throw e;
s += "\n" + more;
}
}
}
return {
parse: parse,
parseStdin: parseStdin,
Node: Node,
DECLARED_FORM: DECLARED_FORM,
EXPRESSED_FORM: EXPRESSED_FORM,
STATEMENT_FORM: STATEMENT_FORM,
Tokenizer: lexer.Tokenizer,
FunctionDefinition: FunctionDefinition
};
}());
var exports = {
definitions: Narcissus.definitions,
lexer: Narcissus.lexer,
parser: Narcissus.parser
};
if (typeof module != 'undefined') {
module.exports = exports;
};
(function() {
var Builders, Code, Node, Types, UnsupportedError, blockTrim, body, build, buildCoffee, exports, ltrim, narcissus, p, paren, parser, re, rtrim, strEscape, strRepeat, tokens, trim, unreserve, unshift, _;
var __slice = Array.prototype.slice;
if (typeof window !== "undefined" && window !== null) {
narcissus = window.Narcissus;
_ = window._;
} else {
narcissus = require('./narcissus_packed');
_ = require('underscore');
}
tokens = narcissus.definitions.tokens;
parser = narcissus.parser;
Node = parser.Node;
buildCoffee = function(str) {
var scriptNode;
scriptNode = parser.parse("" + str + "\n");
return trim(build(scriptNode));
};
Node.prototype.left = function() {
return this.children[0];
};
Node.prototype.right = function() {
return this.children[1];
};
Node.prototype.unsupported = function(msg) {
throw new UnsupportedError("Unsupported: " + msg, this);
};
Node.prototype.typeName = function() {
return Types[this.type];
};
build = function(node, opts) {
var name, out;
if (opts == null) {
opts = {};
}
name = 'other';
if (node !== void 0 && node.typeName) {
name = node.typeName();
}
out = (Builders[name] || Builders.other).apply(node, [opts]);
if (node.parenthesized != null) {
return paren(out);
} else {
return out;
}
};
re = function() {
var args, str, type;
type = arguments[0], str = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
return Builders[type].apply(str, args);
};
body = function(item, opts) {
var str;
if (opts == null) {
opts = {};
}
str = build(item, opts);
str = blockTrim(str);
str = unshift(str);
if (str.length > 0) {
return str;
} else {
return "";
}
};
Types = (function() {
var dict, i;
dict = {};
for (i in tokens) {
if (typeof tokens[i] === 'number') {
dict[tokens[i]] = i.toLowerCase();
}
}
return dict;
})();
Builders = {
'script': function(opts) {
var c, len;
if (opts == null) {
opts = {};
}
c = new Code;
len = this.children.length;
if (len > 0) {
if (opts.returnable != null) {
this.children[len - 1].last = true;
}
if ((opts.noBreak != null) && this.children[len - 1].typeName() === 'break') {
delete this.children[len - 1];
}
}
if (this.children != null) {
_.each(this.children, function(item) {
if (item.typeName() === 'function') {
return c.add(build(item));
}
});
_.each(this.children, function(item) {
if (item.typeName() !== 'function') {
return c.add(build(item));
}
});
}
return c.toString();
},
'identifier': function() {
var str;
str = this.value.toString();
if (str.match(/^([_\$a-z][a-z0-9_]*)$/i) || str.match(/^[0-9]+/i)) {
return unreserve(str);
} else {
return strEscape(str);
}
},
'number': function() {
return "" + this.value;
},
'id': function() {
return unreserve(this);
},
'id_param': function() {
var _ref;
if ((_ref = this.toString()) === 'undefined') {
return "" + this + "_";
} else {
return re('id', this);
}
},
'return': function() {
if (!(this.value != null)) {
return "return";
} else if (this.last != null) {
return build(this.value);
} else {
return "return " + (build(this.value));
}
},
';': function() {
if (!(this.expression != null)) {
return "";
} else if (this.expression.typeName() === 'call') {
return re('call_statement', this.expression) + "\n";
} else {
return build(this.expression) + "\n";
}
},
'new': function() {
return "new " + (build(this.left()));
},
'new_with_args': function() {
return "new " + (build(this.left())) + "(" + (build(this.right())) + ")";
},
'unary_plus': function() {
return "+" + (build(this.left()));
},
'unary_minus': function() {
return "-" + (build(this.left()));
},
'this': function() {
return 'this';
},
'null': function() {
return 'null';
},
'true': function() {
return 'true';
},
'false': function() {
return 'false';
},
'void': function() {
return 'undefined';
},
'break': function() {
return "break\n";
},
'continue': function() {
return "continue\n";
},
'!': function() {
return "not " + (build(this.left()));
},
'~': function() {
return "~" + (build(this.left()));
},
'typeof': function() {
return "typeof " + (build(this.left()));
},
'index': function() {
return "" + (build(this.left())) + "[" + (build(this.right())) + "]";
},
'throw': function() {
return "throw " + (build(this.exception));
},
'+': function() {
return re('binary_operator', this, '+');
},
'-': function() {
return re('binary_operator', this, '-');
},
'*': function() {
return re('binary_operator', this, '*');
},
'/': function() {
return re('binary_operator', this, '/');
},
'%': function() {
return re('binary_operator', this, '%');
},
'>': function() {
return re('binary_operator', this, '>');
},
'<': function() {
return re('binary_operator', this, '<');
},
'&': function() {
return re('binary_operator', this, '&');
},
'|': function() {
return re('binary_operator', this, '|');
},
'^': function() {
return re('binary_operator', this, '^');
},
'&&': function() {
return re('binary_operator', this, 'and');
},
'||': function() {
return re('binary_operator', this, 'or');
},
'in': function() {
return re('binary_operator', this, 'in');
},
'==': function() {
return re('binary_operator', this, '==');
},
'<<': function() {
return re('binary_operator', this, '<<');
},
'<=': function() {
return re('binary_operator', this, '<=');
},
'>>': function() {
return re('binary_operator', this, '>>');
},
'>=': function() {
return re('binary_operator', this, '>=');
},
'!=': function() {
return re('binary_operator', this, '!=');
},
'===': function() {
return re('binary_operator', this, 'is');
},
'!==': function() {
return re('binary_operator', this, 'isnt');
},
'instanceof': function() {
return re('binary_operator', this, 'instanceof');
},
'binary_operator': function(sign) {
return "" + (build(this.left())) + " " + sign + " " + (build(this.right()));
},
'--': function() {
return re('increment_decrement', this, '--');
},
'++': function() {
return re('increment_decrement', this, '++');
},
'increment_decrement': function(sign) {
if (this.postfix) {
return "" + (build(this.left())) + sign;
} else {
return "" + sign + (build(this.left()));
}
},
'=': function() {
var sign;
sign = this.assignOp != null ? Types[this.assignOp] + '=' : '=';
return "" + (build(this.left())) + " " + sign + " " + (build(this.right()));
},
',': function() {
var list;
list = _.map(this.children, function(item) {
return build(item) + "\n";
});
return list.join('');
},
'regexp': function() {
var begins_with, flag, m, value;
m = this.value.toString().match(/^\/(.*)\/([a-z]?)/);
value = m[1];
flag = m[2];
begins_with = value[0];
if (begins_with === ' ' || begins_with === '=') {
if (flag.length > 0) {
return "RegExp(" + (strEscape(value)) + ", \"" + flag + "\")";
} else {
return "RegExp(" + (strEscape(value)) + ")";
}
} else {
return "/" + value + "/" + flag;
}
},
'string': function() {
return strEscape(this.value);
},
'call': function() {
if (this.right().children.length === 0) {
return "" + (build(this.left())) + "()";
} else {
return "" + (build(this.left())) + "(" + (build(this.right())) + ")";
}
},
'call_statement': function() {
var left;
left = build(this.left());
if (this.left().typeName() === 'function') {
left = paren(left);
}
if (this.right().children.length === 0) {
return "" + left + "()";
} else {
return "" + left + " " + (build(this.right()));
}
},
'list': function() {
var list;
list = _.map(this.children, function(item) {
return build(item);
});
return list.join(", ");
},
'delete': function() {
var ids;
ids = _.map(this.children, function(el) {
return build(el);
});
ids = ids.join(', ');
return "delete " + ids + "\n";
},
'.': function() {
if (this.left().typeName() === 'this') {
return "@" + (build(this.right()));
} else {
return "" + (build(this.left())) + "." + (build(this.right()));
}
},
'try': function() {
var c;
c = new Code;
c.add('try');
c.scope(body(this.tryBlock));
_.each(this.catchClauses, function(clause) {
return c.add(build(clause));
});
if (this.finallyBlock != null) {
c.add("finally");
c.scope(body(this.finallyBlock));
}
return c;
},
'catch': function() {
var c;
c = new Code;
if (this.varName != null) {
c.add("catch " + this.varName);
} else {
c.add('catch');
}
c.scope(body(this.block));
return c;
},
'?': function() {
return "(if " + (build(this.left())) + " then " + (build(this.children[1])) + " else " + (build(this.children[2])) + ")";
},
'for': function() {
var c;
c = new Code;
if (this.setup != null) {
c.add("" + (build(this.setup)) + "\n");
}
if (this.condition != null) {
c.add("while " + (build(this.condition)) + "\n");
} else {
c.add("while true");
}
c.scope(body(this.body));
if (this.update != null) {
c.scope(body(this.update));
}
return c;
},
'for_in': function() {
var c;
c = new Code;
c.add("for " + (build(this.iterator)) + " of " + (build(this.object)));
c.scope(body(this.body));
return c;
},
'while': function() {
var c;
c = new Code;
c.add("while " + (build(this.condition)));
c.scope(body(this.body));
return c;
},
'do': function() {
var c;
c = new Code;
c.add("while true");
c.scope(body(this.body));
if (this.condition != null) {
c.scope("break unless " + (build(this.condition)));
}
return c;
},
'if': function() {
var c;
c = new Code;
c.add("if " + (build(this.condition)));
c.scope(body(this.thenPart));
if (this.elsePart != null) {
if (this.elsePart.typeName() === 'if') {
c.add("else " + (build(this.elsePart).toString()));
} else {
c.add("else\n");
c.scope(body(this.elsePart));
}
}
return c;
},
'switch': function() {
var c;
c = new Code;
c.add("switch " + (build(this.discriminant)) + "\n");
_.each(this.cases, function(item) {
var first;
if (item.value === 'default') {
c.scope("else");
} else {
c.scope("when " + (build(item.caseLabel)) + "\n");
}
c.scope(body(item.statements, {
noBreak: true
}), 2);
return first = false;
});
return c;
},
'array_init': function() {
var list;
if (this.children.length === 0) {
return "[]";
} else {
list = re('list', this);
return "[ " + list + " ]";
}
},
'property_init': function() {
return "" + (build(this.left())) + ": " + (build(this.right()));
},
'object_init': function() {
var c, list;
if (this.children.length === 0) {
return "{}";
} else if (this.children.length === 1) {
return build(this.children[0]);
} else {
list = _.map(this.children, function(item) {
return build(item);
});
c = new Code;
c.scope(list.join("\n"));
return c;
}
},
'function': function() {
var c, params;
c = new Code;
params = _.map(this.params, function(str) {
return re('id_param', str);
});
if (this.name) {
c.add("" + this.name + " = ");
}
if (this.params.length > 0) {
c.add("(" + (params.join(', ')) + ") ->");
} else {
c.add("->");
}
c.scope(body(this.body, {
returnable: true
}));
return c;
},
'var': function() {
var list;
list = _.map(this.children, function(item) {
if (item.initializer != null) {
return "" + item.value + " = " + (build(item.initializer));
}
});
return _.compact(list).join("\n") + "\n";
},
'other': function() {
return this.unsupported("" + (this.typeName()) + " is not supported yet");
},
'getter': function() {
return this.unsupported("getter syntax is not supported; use __defineGetter__");
},
'setter': function() {
return this.unsupported("setter syntax is not supported; use __defineSetter__");
},
'label': function() {
return this.unsupported("labels are not supported by CoffeeScript");
},
'const': function() {
return this.unsupported("consts are not supported by CoffeeScript");
}
};
Builders.block = Builders.script;
UnsupportedError = (function() {
function UnsupportedError(str, src) {
this.message = str;
this.cursor = src.start;
this.line = src.lineno;
this.source = src.tokenizer.source;
}
UnsupportedError.prototype.toString = function() {
return this.message;
};
return UnsupportedError;
})();
Code = (function() {
function Code() {
this.code = '';
}
Code.prototype.add = function(str) {
this.code += str.toString();
return this;
};
Code.prototype.scope = function(str, level) {
var indent;
if (level == null) {
level = 1;
}
indent = strRepeat("  ", level);
this.code = rtrim(this.code) + "\n";
this.code += indent + rtrim(str).replace(/\n/g, "\n" + indent) + "\n";
return this;
};
Code.prototype.toString = function() {
return this.code;
};
return Code;
})();
paren = function(string) {
var str;
str = string.toString();
if (str.substr(0, 1) === '(' && str.substr(-1, 1) === ')') {
return str;
} else {
return "(" + str + ")";
}
};
strRepeat = function(str, times) {
var i;
return ((function() {
var _results;
_results = [];
for (i = 0; 0 <= times ? i < times : i > times; 0 <= times ? i++ : i--) {
_results.push(str);
}
return _results;
})()).join('');
};
ltrim = function(str) {
return ("" + str).replace(/^\s*/g, '');
};
rtrim = function(str) {
return ("" + str).replace(/\s*$/g, '');
};
blockTrim = function(str) {
return ("" + str).replace(/^\s*\n|\s*$/g, '');
};
trim = function(str) {
return ("" + str).replace(/^\s*|\s*$/g, '');
};
unshift = function(str) {
var m1, m2, _results;
str = "" + str;
_results = [];
while (true) {
m1 = str.match(/^/gm);
m2 = str.match(/^ /gm);
if (!m1 || !m2 || m1.length !== m2.length) {
return str;
}
_results.push(str = str.replace(/^ /gm, ''));
}
return _results;
};
strEscape = function(str) {
return JSON.stringify("" + str);
};
p = function(str) {
if (typeof str === 'object') {
if (str.tokenizer != null) {
delete str.tokenizer;
}
console.log(str);
} else if (str.constructor === String) {
console.log(JSON.stringify(str));
} else {
console.log(str);
}
return '';
};
unreserve = function(str) {
var _ref;
if ((_ref = "" + str) === 'in' || _ref === 'loop' || _ref === 'off' || _ref === 'on' || _ref === 'when' || _ref === 'not' || _ref === 'until' || _ref === '__bind' || _ref === '__indexOf') {
return "" + str + "_";
} else {
return "" + str;
}
};
exports = {
version: '0.0.3',
build: buildCoffee,
UnsupportedError: UnsupportedError
};
if (typeof window !== "undefined" && window !== null) {
window.Js2coffee = exports;
}
if (typeof module !== "undefined" && module !== null) {
module.exports = exports;
}
}).call(this);
